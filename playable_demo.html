<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playable Character Demo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #87CEEB;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="info">Loading...</div>
    <div id="controls">
        Controls:<br>
        W / A / S / D - Move<br>
        SHIFT - Run<br>
        SPACE - Jump
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Configuration ---
        const MODEL_PATH = './merged/character_all_animations.glb';
        const JSON_PATH = './merged/character_all_animations.json';
        const ROTATION_SPEED = 5.0;
        const WALK_SPEED = 3.0;
        const RUN_SPEED = 6.0;
        
        let animationData = null;

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xa0a0a0);
        scene.fog = new THREE.Fog(0xa0a0a0, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 2, -3);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff);
        dirLight.position.set(3, 10, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- Ground ---
        const mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false })
        );
        mesh.rotation.x = -Math.PI / 2;
        mesh.receiveShadow = true;
        scene.add(mesh);

        const grid = new THREE.GridHelper(100, 40, 0x000000, 0x000000);
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add(grid);

        // --- Input Handling ---
        const keys = {
            w: false, a: false, s: false, d: false,
            shift: false, space: false
        };

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = true;
            if (e.key === 'Shift') keys.shift = true;
            if (e.key === ' ') keys.space = true;
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = false;
            if (e.key === 'Shift') keys.shift = false;
            if (e.key === ' ') keys.space = false;
        });

        // --- Character Controller ---
        let character, mixer;
        let actions = {};
        let activeAction, previousAction;
        let isJumping = false;
        const animationDurations = {};
        const animationCycleDistances = {};

        fetch(JSON_PATH)
            .then(response => response.json())
            .then(data => {
                animationData = data;
                console.log('ðŸ“– Animation data loaded from JSON');
                console.log(`  - Character height: ${data.character.height.toFixed(3)} units`);
                console.log(`  - Walk cycle distance: ${data.animations.find(a => a.name === '36-walk')?.cycleDistance?.toFixed(3) || 'N/A'} units`);
                console.log(`  - Run cycle distance: ${data.animations.find(a => a.name === '30-run')?.cycleDistance?.toFixed(3) || 'N/A'} units`);
                loadModel();
            })
            .catch(err => {
                console.warn('âš ï¸  Could not load animation JSON, using defaults:', err);
                loadModel();
            });
        
        function loadModel() {
        const loader = new GLTFLoader();
        loader.load(MODEL_PATH, (gltf) => {
            character = gltf.scene;
            scene.add(character);

            console.log("=".repeat(60));
            console.log("âœ… CHARACTER LOADED SUCCESSFULLY");
            console.log("=".repeat(60));
            
            console.log(`\nðŸ“¦ MODEL INFO:`);
            console.log(`  - File: ${MODEL_PATH}`);
            console.log(`  - Total Animations: ${gltf.animations.length}`);
            
            let meshCount = 0;
            let boneCount = 0;
            const importantNodes = ['Root', 'Hips', 'Torso', 'Chest', 'Abdomen', 'Head', 'Index4L', 'Index4R'];
            const foundNodes = {};
            
            character.traverse(object => {
                if (object.isMesh) {
                    meshCount++;
                    object.castShadow = true;
                }
                if (object.isBone) boneCount++;
                if (importantNodes.includes(object.name)) {
                    foundNodes[object.name] = true;
                }
            });
            
            console.log(`  - Meshes: ${meshCount}`);
            console.log(`  - Bones: ${boneCount}`);
            console.log(`  - Important Nodes:`);
            importantNodes.forEach(nodeName => {
                console.log(`    ${foundNodes[nodeName] ? 'âœ…' : 'âŒ'} ${nodeName}`);
            });
            
            console.log(`\nðŸŽ¬ AVAILABLE ANIMATIONS (${gltf.animations.length}):`);
            gltf.animations.forEach((clip, i) => {
                console.log(`  ${i + 1}. "${clip.name}" - ${clip.duration.toFixed(3)}s (${clip.tracks.length} tracks)`);
            });

            mixer = new THREE.AnimationMixer(character);

            const clips = gltf.animations;
            const findClip = (term) => clips.find(c => c.name.toLowerCase().includes(term));

            // Helper to calculate cycle distance from Root/Hips/CharacterArmature position track
            const getCycleDistance = (clip) => {
                for (const track of clip.tracks) {
                    const trackName = track.name.toLowerCase();
                    // Look for position tracks on Root, Hips, or CharacterArmature
                    // Track names in Three.js are like: "CharacterArmature.position" or "Root.translation"
                    if ((trackName.includes('root') || trackName.includes('hips') || trackName.includes('armature')) && 
                        (trackName.includes('translation') || trackName.includes('position'))) {
                        if (track.times && track.values) {
                            // Position tracks: 3 values per keyframe (x, y, z)
                            // times.length = number of keyframes
                            // values.length = times.length * 3
                            const numKeyframes = track.times.length;
                            if (numKeyframes >= 2 && track.values.length >= numKeyframes * 3) {
                                // Get first and last Z values (forward direction)
                                const firstZ = track.values[2]; // First keyframe: values[0]=x, values[1]=y, values[2]=z
                                const lastZ = track.values[(numKeyframes - 1) * 3 + 2]; // Last keyframe Z
                                const distance = Math.abs(lastZ - firstZ);
                                if (distance > 0.01) {
                                    console.log(`    ðŸ“ Found cycle distance for ${clip.name}: ${distance.toFixed(3)} units (from ${track.name})`);
                                    return distance;
                                }
                            }
                        }
                    }
                }
                return null;
            };
            
            const idleClip = findClip('18-idle-berathing') || findClip('idle-berathing') || findClip('idle') || clips[0];
            const walkClip = findClip('36-walk') || findClip('walk');
            const runClip = findClip('30-run') || findClip('run');
            // Try to find a better jump animation - avoid backward jumps
            // Prefer simple jump, then long jump, avoid backward
            const jumpClip = findClip('26-jump-simple') || 
                           findClip('24-jump-long') || 
                           findClip('jump-simple') || 
                           clips.find(c => c.name.toLowerCase().includes('jump') && !c.name.toLowerCase().includes('backward'));

            const shouldLoop = (clipName) => {
                const name = clipName.toLowerCase();
                return name.includes('idle') || name.includes('walk') || name.includes('run') || 
                       name.includes('breathing') || name.includes('swimming') || name.includes('treading') ||
                       name.includes('sneaking');
            };
            
            console.log(`\nðŸŽ¯ ANIMATION MAPPING:`);
            if (idleClip) {
                actions.idle = mixer.clipAction(idleClip);
                animationDurations.idle = idleClip.duration;
                actions.idle.setLoop(THREE.LoopRepeat);
                actions.idle.timeScale = 1.0;
                console.log(`  âœ… Idle: "${idleClip.name}" (${idleClip.duration.toFixed(3)}s, loop: ${shouldLoop(idleClip.name)})`);
            } else {
                console.log(`  âŒ Idle: NOT FOUND`);
            }
            
            const removeRootMotionTracks = (clip) => {
                const tracksToKeep = [];
                for (const track of clip.tracks) {
                    const trackName = track.name.toLowerCase();
                    const isRootMotion = (trackName.includes('armature') || trackName.includes('root') || trackName.includes('hips')) && 
                                        (trackName.includes('position') || trackName.includes('translation'));
                    if (!isRootMotion) {
                        tracksToKeep.push(track);
                    }
                }
                if (tracksToKeep.length < clip.tracks.length) {
                    const newClip = new THREE.AnimationClip(clip.name, clip.duration, tracksToKeep);
                    console.log(`    ðŸ”§ Removed ${clip.tracks.length - tracksToKeep.length} root motion tracks from ${clip.name}`);
                    return newClip;
                }
                return clip;
            };
            
            if (walkClip) {
                const walkClipNoRootMotion = removeRootMotionTracks(walkClip);
                actions.walk = mixer.clipAction(walkClipNoRootMotion);
                animationDurations.walk = walkClipNoRootMotion.duration;
                const walkData = animationData?.animations.find(a => a.name === walkClip.name);
                if (walkData && walkData.cycleDistance !== null) {
                    animationCycleDistances.walk = walkData.cycleDistance;
                    console.log(`  âœ… Walk: "${walkClip.name}" (${walkClipNoRootMotion.duration.toFixed(3)}s, loop: ${shouldLoop(walkClip.name)}, cycle: ${walkData.cycleDistance.toFixed(3)} units from JSON, speed: ${walkData.recommendedSpeed?.toFixed(3) || 'N/A'} units/s from JSON)`);
                } else {
                    console.warn(`  âš ï¸  Walk: No cycle distance in JSON, calculating from tracks...`);
                    animationCycleDistances.walk = getCycleDistance(walkClip);
                    const speed = animationCycleDistances.walk ? animationCycleDistances.walk / walkClipNoRootMotion.duration : null;
                    console.log(`  âœ… Walk: "${walkClip.name}" (${walkClipNoRootMotion.duration.toFixed(3)}s, loop: ${shouldLoop(walkClip.name)}, cycle: ${animationCycleDistances.walk?.toFixed(3) || 'N/A'} units (calculated), speed: ${speed?.toFixed(3) || 'N/A'} units/s)`);
                }
                actions.walk.setLoop(THREE.LoopRepeat);
                actions.walk.timeScale = 1.0;
            } else {
                console.log(`  âŒ Walk: NOT FOUND`);
            }
            
            if (runClip) {
                const runClipNoRootMotion = removeRootMotionTracks(runClip);
                actions.run = mixer.clipAction(runClipNoRootMotion);
                animationDurations.run = runClipNoRootMotion.duration;
                const runData = animationData?.animations.find(a => a.name === runClip.name);
                if (runData && runData.cycleDistance !== null) {
                    animationCycleDistances.run = runData.cycleDistance;
                    console.log(`  âœ… Run: "${runClip.name}" (${runClipNoRootMotion.duration.toFixed(3)}s, loop: ${shouldLoop(runClip.name)}, cycle: ${runData.cycleDistance.toFixed(3)} units from JSON, speed: ${runData.recommendedSpeed?.toFixed(3) || 'N/A'} units/s from JSON)`);
                } else {
                    console.warn(`  âš ï¸  Run: No cycle distance in JSON, calculating from tracks...`);
                    animationCycleDistances.run = getCycleDistance(runClip);
                    const speed = animationCycleDistances.run ? animationCycleDistances.run / runClipNoRootMotion.duration : null;
                    console.log(`  âœ… Run: "${runClip.name}" (${runClipNoRootMotion.duration.toFixed(3)}s, loop: ${shouldLoop(runClip.name)}, cycle: ${animationCycleDistances.run?.toFixed(3) || 'N/A'} units (calculated), speed: ${speed?.toFixed(3) || 'N/A'} units/s)`);
                }
                actions.run.setLoop(THREE.LoopRepeat);
                actions.run.timeScale = 1.0;
            } else {
                console.log(`  âŒ Run: NOT FOUND`);
            }
            
            if (jumpClip) {
                actions.jump = mixer.clipAction(jumpClip);
                animationDurations.jump = jumpClip.duration;
                actions.jump.setLoop(THREE.LoopOnce);
                actions.jump.clampWhenFinished = true;
                actions.jump.timeScale = 1.0;
                console.log(`  âœ… Jump: "${jumpClip.name}" (${jumpClip.duration.toFixed(3)}s, loop: false)`);
            } else {
                console.log(`  âš ï¸  Jump: NOT FOUND (optional)`);
            }
            
            console.log(`\nâ±ï¸  Animation Durations (dynamic):`);
            Object.keys(animationDurations).forEach(key => {
                const loop = key === 'jump' ? 'No' : 'Yes';
                console.log(`  - ${key}: ${animationDurations[key].toFixed(3)}s (loop: ${loop})`);
            });

            console.log(`\nðŸŽ® CONTROLS:`);
            console.log(`  W/A/S/D - Move`);
            console.log(`  SHIFT - Run`);
            console.log(`  SPACE - Jump`);
            
            console.log(`\nðŸ“Š RUNTIME INFO:`);
            console.log(`  - Active Animation: Will be logged during gameplay`);
            console.log(`  - Input Status: Will be logged during gameplay`);
            
            console.log("=".repeat(60));

            activeAction = actions.idle;
            if (activeAction) activeAction.play();

            document.getElementById('info').innerText = 'Character Loaded. Ready!';

            animate();
        }, undefined, (e) => {
            console.error(e);
            document.getElementById('info').innerText = 'Error loading model: ' + e.message;
        });
        }

        let lastActionName = '';
        let lastInputState = '';
        
        function fadeToAction(name, fadeDuration = 0.2) {
            previousAction = activeAction;
            activeAction = actions[name];

            if (previousAction !== activeAction && activeAction) {
                previousAction.fadeOut(fadeDuration);
                activeAction.reset().fadeIn(fadeDuration).play();
                
                if (lastActionName !== name) {
                    const clip = activeAction.getClip();
                    const duration = animationDurations[name] || clip.duration;
                    const loop = name === 'jump' ? 'once' : 'repeat';
                    console.log(`ðŸŽ¬ Animation: ${previousAction?.getClip().name || 'none'} â†’ ${clip.name} (${duration.toFixed(3)}s, ${loop})`);
                    lastActionName = name;
                }
            }
        }

        const clock = new THREE.Clock();

        function updateCharacter(delta) {
            if (!character) return;

            const direction = new THREE.Vector3();
            let moving = false;
            const activeKeys = [];

            if (keys.w) { direction.z += 1; moving = true; activeKeys.push('W'); }
            if (keys.s) { direction.z -= 1; moving = true; activeKeys.push('S'); }
            if (keys.a && !isJumping) { character.rotation.y += ROTATION_SPEED * delta; activeKeys.push('A'); }
            if (keys.d && !isJumping) { character.rotation.y -= ROTATION_SPEED * delta; activeKeys.push('D'); }
            if (keys.shift) activeKeys.push('SHIFT');
            if (keys.space) activeKeys.push('SPACE');

            const inputState = activeKeys.length > 0 ? activeKeys.join('+') : 'NONE';
            if (inputState !== lastInputState && activeKeys.length > 0) {
                console.log(`âŒ¨ï¸  Input: ${inputState}`);
                lastInputState = inputState;
            } else if (inputState === 'NONE' && lastInputState !== 'NONE') {
                console.log(`âŒ¨ï¸  Input: NONE`);
                lastInputState = inputState;
            }

            if (keys.space && actions.jump && !isJumping) {
                fadeToAction('jump', 0.1);
                isJumping = true;
                const wasMoving = moving;
                const wasRunning = keys.shift;
                const jumpDuration = animationDurations.jump ? animationDurations.jump * 1000 : 1000;
                setTimeout(() => { 
                    isJumping = false;
                    if (wasMoving) {
                        if (wasRunning && actions.run) {
                            fadeToAction('run', 0.2);
                        } else if (actions.walk) {
                            fadeToAction('walk', 0.2);
                        }
                    } else {
                        if (actions.idle) fadeToAction('idle', 0.2);
                    }
                }, jumpDuration);
            }
            
            if (moving && !isJumping) {
                if (keys.shift && actions.run) {
                    fadeToAction('run', 0.2);
                } else if (actions.walk) {
                    fadeToAction('walk', 0.2);
                }
            } else if (!isJumping) {
                if (actions.idle) {
                    fadeToAction('idle', 0.2);
                }
            }

            if (moving && !isJumping) {
                const moveSpeed = keys.shift ? RUN_SPEED : WALK_SPEED;
                const forward = new THREE.Vector3(0, 0, 1);
                forward.applyQuaternion(character.quaternion);
                forward.multiplyScalar(moveSpeed * delta);
                character.position.add(forward);
            }
        }

        let frameCount = 0;
        let lastFPSLog = 0;
        
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            frameCount++;

            if (mixer) mixer.update(delta);
            updateCharacter(delta);

            if (character) {
                character.updateMatrixWorld();
                const relativeOffset = new THREE.Vector3(0, 2, -3);
                const cameraOffset = relativeOffset.applyMatrix4(character.matrixWorld);
                camera.position.lerp(cameraOffset, 0.1);
                camera.lookAt(character.position.clone().add(new THREE.Vector3(0, 1.5, 0)));
            }

            renderer.render(scene, camera);
            
            if (Date.now() - lastFPSLog > 5000) {
                const fps = Math.round(frameCount / ((Date.now() - lastFPSLog) / 1000));
                console.log(`ðŸ“Š Performance: ~${fps} FPS | Position: (${character.position.x.toFixed(2)}, ${character.position.y.toFixed(2)}, ${character.position.z.toFixed(2)})`);
                frameCount = 0;
                lastFPSLog = Date.now();
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>